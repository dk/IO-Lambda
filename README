IO::Lambda - nonblocking IO in functional style
===============================================

This module is another attempt to fight the horrors of non-blocking IO
programming. The simplicitly of the classic, blocking style is only available
when one employs threads or coroutines. Otherwise, state machines have to be
built, often quite complex, and this approach doesn't help the clarity of the
code. The approach implemented in this module is stringly based on closures.
It emulates the blocking style, so the collection of states is local, and can
be collected under single subroutine. For example, a dumbed down HTTP protocol
can be described like in the following scheme:

	write {
		print $fh or die;
		read {
			sysread $fh or die;
			read_again;
		}
	}

IO::Lambda tries to actually implement that. The following code shows how:

	# prepare the request
	use IO::Lambda qw(:all);
	use IO::Socket::INET;
	my $q     = IO::Lambda-> new;
	my $sock  = IO::Socket::INET-> new( PeerAddr => 'localhost', PeerPort => 80);
	die "cannot connect:$@" unless $sock;
	
	# declare the object context
	self_context( $q, $sock);

	# wait for the socket to become writable
	write { 
		print $sock "GET / HTTP/1.0\r\n\r\n";
		my $buf = '';
		# wait for the socket to become readable
		read {
			my $n = sysread( $sock, $buf, 1024, length($buf));
			return "error:$!" unless defined $n;
			return $buf unless $n;
			again;
		}
	};

	finally {
		print shift;
	};

	# execute
	$q-> wait;

This approach allows to lay out the protocol locally, without spreading its individual
stages through the code. The http transport protocol, as described here, can be 
simplified to this scheme:

and the module guarantees that at whatever stage the protocol stops, the last execution result,
be it error string or http response, will be delivered to the receiver.

The aim of the module is two-fold. First, to bring back the terseness in non-blocking IO, without
resorting to the drastic measures of threads and coroutines. Second, to create a framework where
protocols are subroutines. That means, when a lower-lever protocol is described as a single
routine (as http above), callers can wrap it easily and construct higher-lever protocols on top
of it, again, resulting in a protocol that will also be a single subroutine. For example, a
HTTP handler that can understand redirection:

	# create chain of event on an existsing lambda object, that when
	# finished, will contain the result
	sub http_request
	{
		my ($q, $req) = @_;
		my $socket = socket_to_http_request( $req);
		self_context( $q, $socket);
		write {
			print $socket $req or return "error:$!";
			my $buf = '';
			read {
				my $n = sysread( $socket, $buf, 1024, length($buf));
				return "error:$!" unless defined $n;
				return $buf unless $n;
				again;
			};
			
		};
	}

	# wrap http_request by listening to events from http_request
	sub http_redirect_request
	{
		my ( $q, $req) = @_;

		my $subq = IO::Lambda-> new;
		http_request( $subq, $req);

		self_context( $q, $subq);
		pipeline {
			my $result = shift;
			return $result unless ref($result) eq 'HTTP::Response';
			return $result if $result-> code =~ s/^30/;
			$req-> uri( $result-> header('Location'));
			push_context;
			http_request( $subq, $req);
			pop_context;
			again;
		};
	}

	# main call
	my $q = IO::Lambda-> new;
	http_request( $q, HTTP::Request-> new(...));
	$q-> tail( sub { print shift } );
	$q-> wait;
